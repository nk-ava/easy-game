<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../assets/css/common.css"/>
    <title>2048小游戏</title>
    <style>
        html,
        body {
            text-align: center;
        }

        .cell-box {
            background-color: #bbac9f;
            margin: 0 auto;
            border-radius: 10px;
            display: grid;
            padding: 8px;
            row-gap: 5px;
            column-gap: 8px;
            width: 100%;
            aspect-ratio: 1;
            box-sizing: border-box;
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: orange;
            border-radius: 5px;
            font-weight: bold;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
<div class="container">
    <div class="cell-box"></div>
    <p>剩<span class="unDeal"></span>个空方格未合并</p>
    <p>当前分数：<span class="sc"></span></p>
</div>
<script lang="text/javascript">
    (() => {
        const fontSize = [0, 45, 40, 30, 30];
        const touches = {};
        const bgColor = {
            default: '#cdc0b2',
            2: '#eee3d9',
            4: '#ebdcbd',
            8: '#f2b279',
            16: '#f7925c',
            32: '#f57756',
            64: '#f5522e',
            128: '#eecf71',
            256: '#e6d153',
            512: '#cea30c',
            1024: '#d88e00',
            2048: '#c77800'
        };
        const n = 4
        const cellBox = document.querySelector(".cell-box")
        const unDeal = document.querySelector(".unDeal")
        const sc = document.querySelector(".sc")
        // 下右两个方向
        const direction = [[1, 0], [0, 1]]
        // 未合并的数字方格数量
        let unDealCount = 0
        // 分数
        let score = 0
        // 数字
        let arr = Array.from({length: n}, () => Array.from({length: n}))

        // 画出方格
        cellBox.style.cssText = `grid-template-columns: repeat(${n}, minmax(0, 1fr)); grid-template-rows: repeat(${n}, minmax(0, 1fr));`
        for (let i = 0; i < n * n; i++) {
            const cell = document.createElement("div")
            cell.className = "cell"
            cellBox.appendChild(cell)
        }

        const cells = document.querySelectorAll(".cell")

        genRandomNumber()
        draw()

        // 手势控制
        cellBox.addEventListener("touchstart", (e) => {
            for (let t of e.changedTouches) {
                touches[t.identifier] = {
                    x: t.screenX,
                    y: t.screenY
                };
            }
        });
        cellBox.addEventListener("touchend", (e) => {
            let isMoving = false;
            for (let t of e.changedTouches) {
                if (!isMoving) {
                    isMoving = true;
                    const touch = touches[t.identifier];
                    const offsetX = t.screenX - touch.x;
                    const offsetY = t.screenY - touch.y;
                    if (Math.abs(offsetX) >= Math.abs(offsetY)) {
                        runMerge(offsetX > 0 ? 'ArrowRight' : 'ArrowLeft');
                    } else {
                        runMerge(offsetY > 0 ? 'ArrowDown' : 'ArrowUp');
                    }
                }
                delete touches[t.identifier];
            }
        });
        // 方向控制
        document.addEventListener("keyup", (e) => {
            runMerge(e.key);
        })

        function draw() {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const elem = cells[i * n + j]
                    elem.innerHTML = arr[i][j] || ""
                    const cnt = numLen(arr[i][j]) || 0
                    const fSize = fontSize[cnt];
                    elem.style.cssText = `padding-top: calc(50% - ${fSize / 2 + 10}px); font-size: ${fSize}px; background-color: ${bgColor[arr[i][j]] || '#cdc0b2'};color: ${arr[i][j] >= 8 ? '#fff' : '#7a6c65'}`
                }
            }
            unDeal.innerHTML = unDealCount
            sc.innerHTML = score
        }

        // 合并规则
        // 1. 只合并相同数字的
        // 2. 只合并相邻的
        // 3. 每个数字最多算一次
        /**
         * @param index 下标，对应行或列的下标
         * @param indexType 0: 行， 1： 列
         * @param isReverse 方向是否反转，默认从上到下，从左到右
         */
        function cellMerge(index, indexType, isReverse = false) {
            let previousVal = -1
            let currentIndex = isReverse ? n - 1 : 0
            let isChange = false
            for (let i = 0; i < n; i++) {
                let useIndex = isReverse ? n - i - 1 : i
                let currentVal = indexType === 0 ? arr[index][useIndex] : arr[useIndex][index]
                if (currentVal === undefined) continue
                if (currentVal === previousVal) {
                    const delta = isReverse ? 1 : -1
                    if (!isChange && useIndex !== currentIndex + delta) isChange = true
                    if (indexType === 0) arr[index][currentIndex + delta] = 2 * currentVal
                    else arr[currentIndex + delta][index] = 2 * currentVal
                    score += 2 * currentVal
                    previousVal = -1
                    unDealCount--
                } else {
                    if (!isChange && useIndex !== currentIndex) isChange = true
                    if (indexType === 0) arr[index][currentIndex] = currentVal
                    else arr[currentIndex][index] = currentVal
                    previousVal = currentVal
                    if (isReverse) currentIndex--
                    else currentIndex++
                }
            }
            const len = isReverse ? currentIndex + 1 : n - currentIndex
            const start = isReverse ? 0 : currentIndex
            for (let i = 0; i < len; i++) {
                if (indexType === 0) {
                    arr[index][start + i] = undefined
                } else {
                    arr[start + i][index] = undefined
                }
            }
            return isChange
        }

        /**
         * 执行合并
         * @param direction 方向
         */
        function runMerge(direction) {
            let isChange = false
            switch (direction) {
                case "ArrowUp":
                    for (let i = 0; i < n; i++) {
                        isChange = cellMerge(i, 1, false) || isChange
                    }
                    break
                case "ArrowDown":
                    for (let i = 0; i < n; i++) {
                        isChange = cellMerge(i, 1, true) || isChange
                    }
                    break
                case "ArrowLeft":
                    for (let i = 0; i < n; i++) {
                        isChange = cellMerge(i, 0, false) || isChange
                    }
                    break
                case "ArrowRight":
                    for (let i = 0; i < n; i++) {
                        isChange = cellMerge(i, 0, true) || isChange
                    }
                    break
                default:
                    return
            }
            if (isChange) {
                const rst = genRandomNumber()
                draw()
                rst && console.log("你已经没有可合成的方格了")
            }
        }

        function genRandomNumber() {
            const val = Math.random() > 0.5 ? 4 : 2
            let targetIndex = Math.floor(Math.random() * (n * n - unDealCount))
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (arr[i][j]) continue
                    if (targetIndex <= 0) {
                        arr[i][j] = val
                        unDealCount++
                        return isOver()
                    }
                    targetIndex--
                }
            }
        }

        function isOver() {
            if (unDealCount < n * n) return false
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    for (let d of direction) {
                        const nextI = i + d[0]
                        const nextJ = j + d[1]
                        if (nextI >= 0
                            && nextI < n
                            && nextJ >= 0
                            && nextJ < n
                            && (arr[i][j] === arr[nextI][nextJ] || arr[nextI][nextJ] === undefined)
                        ) {
                            return false
                        }
                    }
                }
            }
            return true
        }

        function startNew() {
            unDealCount = 0
            score = 0
            arr = Array.from({length: n}, () => Array.from({length: n}))
            genRandomNumber()
            draw()
        }

        // 只支持1——2048之间的数值判断
        function numLen(num) {
            if (num > 999) {
                return 4
            } else if (num > 99) {
                return 3
            } else if (num > 9) {
                return 2
            } else {
                return 1
            }
        }
    })()
</script>
</body>

</html>